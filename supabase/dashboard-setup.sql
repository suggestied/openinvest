-- ----------------------------------------------
-- ADMIN ROLE SETUP 
-- ----------------------------------------------
create type public.app_permission as enum ('admin_all');
create type public.app_role as enum ('admin');

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

insert into public.role_permissions (role, permission)
values
  ('admin', 'admin_all');

-- Create the auth hook function to add the user role to the claims
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    -- Fetch the user role in the user_roles table
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);

    -- Return the modified or original event
    return event;
  end;
$$;

grant usage on schema public to supabase_auth_admin;

grant execute on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute on function public.custom_access_token_hook
  from authenticated, anon, public;

grant all on table public.user_roles to supabase_auth_admin;

revoke all
  on table public.user_roles
  from authenticated, anon, public;

create policy "Allow auth admin to read user roles" ON public.user_roles 
as permissive for select 
to supabase_auth_admin 
using (true);

-- Accessing custom claims in RLS policies
create or replace function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
  user_role public.app_role;
begin
  -- Fetch user role once and store it to reduce number of calls
  select (auth.jwt() ->> 'user_role')::public.app_role into user_role;

  select count(*)
  into bind_permissions
  from public.role_permissions
  where role_permissions.permission = requested_permission
    and role_permissions.role = user_role;

  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = '';

-- ----------------------------------------------
-- NOTIFICATION CAMPAIN SETUP START
-- ----------------------------------------------
create type public.notification_status as enum ('scheduled', 'sent', 'failed');

create table public.notification_campaigns (
  id            uuid primary key default (gen_random_uuid()),
  title         text not null,
  body          text not null,
  scheduled_at  timestamp with time zone not null,
  created_at    timestamp with time zone default now(),
  channel       text null,
  extra_data    jsonb null,
  status        notification_status not null
) tablespace pg_default;

alter table public.notification_campaigns enable row level security;

create policy "Enable read only for admin" on public.notification_campaigns 
for select TO public USING ((SELECT authorize('admin_all')));

create policy "Enable insert for admin" on public.notification_campaigns 
  FOR INSERT with check ((SELECT authorize('admin_all')));

create policy "Enable update for admin" on public.notification_campaigns 
for update TO public USING ((SELECT authorize('admin_all')));

create policy "Enable delete for admin" on public.notification_campaigns
for delete TO public USING ((SELECT authorize('admin_all')));

-- ----------------------------------------------
-- POLICIES UPDATE 
-- ----------------------------------------------

DROP POLICY IF EXISTS "Users can select" ON public.user_infos;
DROP POLICY IF EXISTS "Enable read based on user_id." ON public.subscriptions;
DROP POLICY IF EXISTS "Enable read based on user_id." ON public.notifications;
DROP POLICY IF EXISTS "Enable select access for users based on their user ID *" ON public.devices;

-- user_infos table 
CREATE POLICY "Users can select" ON public.user_infos
  FOR SELECT TO public USING (auth.uid() = user_id OR (SELECT authorize('admin_all')));

-- subscription table 
create policy "Enable read based on user_id." on public.subscriptions
  for select TO public USING (auth.uid() = user_id OR (SELECT authorize('admin_all')));

CREATE POLICY "Enable insert for admin" ON public.subscriptions 
  FOR INSERT with check ((SELECT authorize('admin_all')));

-- notifications table
create policy "Enable read based on user_id." on public.notifications
  for select TO public USING (auth.uid() = user_id OR (SELECT authorize('admin_all')));

CREATE POLICY "Enable insert for admin" ON public.notifications 
  FOR INSERT with check ((SELECT authorize('admin_all')));

-- devices table
create policy "Enable select access for users based on their user ID *" on public.devices
  for select TO public USING (auth.uid() = user_id OR (SELECT authorize('admin_all')));